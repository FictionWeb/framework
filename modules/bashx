#!/bin/bash
_green="$(tput setaf 2)"
_red="$(tput setaf 1)"
_white="$(tput setaf 255)"
_bold="$(tput bold)"
_nc="$(tput sgr 0)"
function _render() {
local level=0 flevel=0 inscript=false output='' i=0 tag=''
local -a parent=() extra=()
function @error() {
  [[ ${#FUNCNAME[@]} > 1 ]] && echo -n "(${FUNCNAME[1]}) " >&2
  echo "${_red}Error:${_nc} ${@}" >&2
}
while read -r line; do 
 # echo "line: $line" >&2
  [[ "$nextline" ]] && local buf="$line" && line="$nextline" && nextline="$buf"
  if [[ "$line" == '' || "${line::1}" == '#' || "${line::3}" == '<--' ]]; then # skip empty lines and comments
    continue
  elif [[ "$line" =~ "html {" ]]; then 
    continue
  elif [[ "${line::1}" == '<' ]]; then # check if it's html tag
    #echo "$line" >&2
    if echo "${line## }" | grep -qE '^[[:space:]]*</?([A-Z][a-zA-Z0-9]*)\b'; then # regex if it's a custom element or native html
      [[ "$line" =~ /\>.* ]] && nextline=$(sed 's|^.*/>\(.*\)|\1|' <<< "$line") && line="${line//$nextline}" 
      line="${line%%\/\>}"
      line="${line%%\>}"
      line="${line##\<}"
      output+="$line"$'\n' # only keep the function and it's arguments
    else
      read tag _ <<< "$line"
      if [[ "$tag" == '<script' ]]; then 
        if [[ "$line" =~ 'bash' ]]; then # if lang="bash", the code will be directly executed
          inscript=true
        elif [[ "$line" =~ 'dom' ]]; then # if lang="dom", the code will be executed but added as js code
          local dom=true;
          output+=$'printf "%s" "<script>"\n';
        fi
      elif [[ "$tag" =~ '</script' ]]; then 
        if [[ "$inscript" == true ]]; then 
          inscript=false
        else
          output+=$'printf "%s" "</script>"\n';
          [[ "$dom" ]] && unset dom
        fi
      else
          if [[ "$line" =~ on: ]]; then
            line="${line%%\>}";
            line="${line##\<}";
            local arg attr key events;
            read el args <<< "$line";
            #set -- $args
            while read arg; do 
              IFS='=' read key value <<< "${arg}"; 
              @unquote value
              if [[ -z "$key" ]]; then 
                continue
              fi 
              case "$key" in
                js-on:*) key="${key//js-on:}"; events+="on${key,,}=\"$($value)\" " ;;
                on:*) key="${key//on:}"; _events+="on${key,,}=\"\$(addServerAction "$value")\" " ;;
                on*)  events+="${key,,}=\"$value\" " ;;
                *)  attr+="$key=\"$value\" "
              esac
            done <<< "$args"
            output+="printf '%s' \"<$el $attr $events>'\""$'\n'
            unset el args key events arg
          elif [[ "$line" =~ '</'|'<body'|'<main'|'<div' ]]; then
            output+="printf '%s\n' '${line}'"$'\n'
          else
          output+="printf '%s' \"${line//\"/\\\"}\""$'\n'
          fi
      fi
      unset tag _
    fi 
  else
    # skip reserved words or code to execute, replace {placeholder} if <a data-bind="placeholder"></a> for bindState()
    if [[ "$line" =~ '{@children}'|'{cache}'|'{/cache}'|'@return' || "$inscript" == true || "$dom" == true ]]; then 
      output+="$line"$'\n'
    else 
      [[ "$line" =~ '{' && "$line" =~ '}' ]] && line=$(echo "$line" | sed 's|{\([^[:space:]]\+\)}|<a data-bind="\1"></a>|g')
      output+="printf '%s' \"${line//\"/\\\"}\""$'\n'
    fi 
  fi
done
#output="$(echo "$output" | sed 's|\(.*\)}|\1|')"
# <<< "${input}"

render_output="$output"
unset input output level flevel i inscript parent line nextline
} 

bashx() {
#set -x
if [ -f "$1" ]; then 
  input=$(sed -E 's#(.*)\@return[[:space:]](json|html)[[:space:]]*\{[[[:space:]]*]?(.*)[^^]\}(.*)$#\1\n\@return \2 \{\n\3\n}\n\4#g' "$1") 
else 
  return 1
fi
local time=$(date +%s%3N)
#local input=$(echo "${input//\\n}" | sed 's|\([a-zA-Z|"]\)>|\1>\n|g; s|\(</[^>]*>\)|\n\1|g') # split code into elements
local out1="${input//$'\n'/#NEWLIN#}" 
local out2=$(echo "$input" | awk 'function count(s, c) { n=0; for (i=1; i<=length(s); i++) if (substr(s, i, 1) == c) n++; return n } /^[[:space:]]*@return[[:space:]](html|json)[[:space:]]*{[[:space:]]*$/ { in_block=1; depth=1; print; next } in_block { o=count($0,"{"); c=count($0,"}"); depth+=o-c; print; if (depth==0) { in_block=0; print "\r" } }')
#echo "$out2" 
#return
while read -d $'\r' block; do
  #echo "${block}"
  block1=$(echo "${block//$'\n'}" | sed 's|\([a-zA-Z0-9|"|\@|\/]\)>|\1>\n|g; s|\(</[^>]*>\)|\n\1|g') 
  if [[ "${block//$'\n'}" =~ 'html' ]]; then
    block1="${block1%%\}}"
    _render "" <<< "${block1/@return html \{}"
    local newblock="{"$'\n'"${render_output}"$'\n'"}"
  elif [[ "${block//$'\n'}" =~ "json" ]]; then 
    local newblock="${block/@return json}"
    newblock="${newblock//\};/\}}"
    newblock="${newblock//$'\n'/ }"
    newblock=$(cat <<-eof
echo "${newblock//\"/\\\"}"
eof
)
    newblock="${newblock//  }"
  fi
  newblock="${newblock##$'\n'}"
  block="${block//$'\n'/#NEWLIN#}"
  block="${block//\[/\\\[}"
  block="${block//\]/\\\]}"
  out1="${out1//$block/${newblock% }}"
done <<< "$out2"
[[ "$BASHX_VERBOSE" ]] && { 
  printf "%s\n" "[$_greenâœ“$_nc] Compiled $1 ($(($(date +%s%3N)-time))ms)" 
}
unset input out out2 block time
if [[ "$2" ]]; then 
  echo "$1:"
  echo "${out1//#NEWLIN#/$'\n'}" 
  printf "\n"
else 
  BASHX_FILENAME="$(readlink -f "$1")"
  eval "${out1//#NEWLIN#/$'\n'}"
fi
unset out out1 out2 block
#set -x
}
function @parse {
  _events=''
  for arg in "$@"; do 
    IFS='=' read key value <<< "${arg}"; 
    if [[ -z "$key" ]]; then 
      continue
    fi 
    case "$key" in
      js-on:*)
        key="${key//js-on:}"
        value="${value##\'}"
        value="${value//\'}"
        _events+="on${key,,}=\"$($value)\" "
        ;;
      on:*)
        key="${key//on:}"
        value="${value##\'}"
        value="${value//\'}"
        _events+="on${key,,}=\"\$(addServerAction "$value")\" "
        ;;
      on*)
        _events+="${key,,}=\"$value\" "
      ;;
      *) 
        printf -v "$key" "%s" "$value"
      esac
  done
}

function @exclude {
  local list="${1}" result=()
  for arg in "${@:2}"; do
    IFS='=' read key value <<< "${arg}"; 
    [[ -z "$key" ]] && continue
    printf -v "$key" "%s" "$value"
    [[ "$key" =~ $list ]] && continue 
    result+=("$key='$value'")
  done
  set -- ${result[@]}
}

function @require {
  for arg in $@; do 
    declare -F $arg || echo "Error: required $arg is not found" 
  done
}

function @unquote {
 for key in "$@"; do
    local -n key1=$key
    key1="${key1%%\'}"; key1="${key##\'}"; key1="${key##\"}"; printf -v "$key" "${key1%%\"}"; 
  done
}

function @wrapper() {
  for key in $@; do 
    [ -z "$(declare -F "$key")" ] && return
    eval "$(declare -f "$key" | sed "s+{@children};+}; /${key}() {+g")"
  done
}

function import() {
  # Syntax: import <filename>  || import <filename> as <ElementAlias>
  # import <function> from <filename> || import <function> from <filename> as <ElementAlias>
  local name filename
  [ -z "$name" ] && name="$1"
  shift
  if [[ "$1" == "as" ]]; then
    if [ -d "$name" ]; then 
      name="$name/index.sh"
    elif [ ! -f "$name" ]; then
      echo "$name not found to import."
      exit 1
    fi
    shift
    if [ -z "$1" ]; then
      fn_name=""${name%.*}""
    else
      fn_name="$1"
    fi
    eval "${fn_name}() { $(cat "$name") }"
  elif [[ "$1" == "from" ]]; then
    shift
    filename="$1"
    if [ ! -f "$filename" ]; then
      error "$name not found to import."
      exit 1
    fi
    [[ "$filename" =~ .shx|.bashx ]] && local funcout="$(bashx "$filename" && declare -f "$name" && declare -f "/$name")" || local funcout="$(. "$filename" && declare -f "$name")"
    [ -z "$funcout" ] && error "$name is not found in $filename" && return 1
    shift
    if [[ "$1" == "as" ]]; then
      shift
      if [ -z "$1" ]; then
        fn_name="${name%.*}"
      else
        fn_name="$1"
      fi
      eval "${funcout/$name/$fn_name}"
    else
      [[ "$funcout" ]] && eval "$funcout"
    fi
  else 
    [[ -n "$name" ]] && { [[ "$name" =~ .shx|.bashx ]] && bashx "$name" || source "$name"; }
  fi
}

if (return 0 2>/dev/null); then
  [[ -z "$BASHX_NESTED" ]] && BASHX_NESTED=true && bashx "${BASH_SOURCE[-1]}"
  return
elif [[ -z $BASHX_NESTED ]]; then
  BASHX_NESTED=true 
  if [ -z "$1" ]; then
    @error "Invalid usage: Use $0 [filename]"
    exit 1
  elif [ -f "$1" ]; then
    filename="$1" 
    [[ "$filename" != "${filename##*/}" ]] && cd "${filename%/*}" && filename="${filename##*/}"
    bashx "$filename"
    exit
  else
    @error "$1 is not found"
    exit 1
  fi
fi